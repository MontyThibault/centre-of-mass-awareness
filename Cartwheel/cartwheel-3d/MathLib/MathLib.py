# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.39
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_MathLib', [dirname(__file__)])
        except ImportError:
            import _MathLib
            return _MathLib
        if fp is not None:
            try:
                _mod = imp.load_module('_MathLib', fp, pathname, description)
            finally:
                fp.close()
                return _mod
    _MathLib = swig_import_helper()
    del swig_import_helper
else:
    import _MathLib
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import Utils
class Matrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _MathLib.new_Matrix(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _MathLib.delete_Matrix
    __del__ = lambda self : None;
    def loadZero(self): return _MathLib.Matrix_loadZero(self)
    def loadIdentity(self): return _MathLib.Matrix_loadIdentity(self)
    def setToOuterproduct(self, *args): return _MathLib.Matrix_setToOuterproduct(self, *args)
    def resizeTo(self, *args): return _MathLib.Matrix_resizeTo(self, *args)
    def shallowCopy(self, *args): return _MathLib.Matrix_shallowCopy(self, *args)
    def deepCopy(self, *args): return _MathLib.Matrix_deepCopy(self, *args)
    def getColumnCount(self): return _MathLib.Matrix_getColumnCount(self)
    def getRowCount(self): return _MathLib.Matrix_getRowCount(self)
    def multiplyBy(self, *args): return _MathLib.Matrix_multiplyBy(self, *args)
    def setToProductOf(self, *args): return _MathLib.Matrix_setToProductOf(self, *args)
    def setToInverseOf(self, *args): return _MathLib.Matrix_setToInverseOf(self, *args)
    def printMatrix(self): return _MathLib.Matrix_printMatrix(self)
    def setToSubmatrix(self, *args): return _MathLib.Matrix_setToSubmatrix(self, *args)
    def get(self, *args): return _MathLib.Matrix_get(self, *args)
    def set(self, *args): return _MathLib.Matrix_set(self, *args)
    def setValues(self, *args): return _MathLib.Matrix_setValues(self, *args)
    def getMatrixPointer(self): return _MathLib.Matrix_getMatrixPointer(self)
    def __mul__(self, *args): return _MathLib.Matrix___mul__(self, *args)
    def postMultiplyVector(self, *args): return _MathLib.Matrix_postMultiplyVector(self, *args)
    def add(self, *args): return _MathLib.Matrix_add(self, *args)
    def sub(self, *args): return _MathLib.Matrix_sub(self, *args)
Matrix_swigregister = _MathLib.Matrix_swigregister
Matrix_swigregister(Matrix)


def testMatrixClass():
  return _MathLib.testMatrixClass()
testMatrixClass = _MathLib.testMatrixClass
class TransformationMatrix(Matrix):
    __swig_setmethods__ = {}
    for _s in [Matrix]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransformationMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [Matrix]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransformationMatrix, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _MathLib.delete_TransformationMatrix
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _MathLib.new_TransformationMatrix(*args)
        try: self.this.append(this)
        except: self.this = this
    def setOGLValues(self, *args): return _MathLib.TransformationMatrix_setOGLValues(self, *args)
    def getValues(self, *args): return _MathLib.TransformationMatrix_getValues(self, *args)
    def getOGLValues(self, *args): return _MathLib.TransformationMatrix_getOGLValues(self, *args)
    def setToProductOf(self, *args): return _MathLib.TransformationMatrix_setToProductOf(self, *args)
    def setToTranslationMatrix(self, *args): return _MathLib.TransformationMatrix_setToTranslationMatrix(self, *args)
    def setToRotationMatrix(self, *args): return _MathLib.TransformationMatrix_setToRotationMatrix(self, *args)
    def __mul__(self, *args): return _MathLib.TransformationMatrix___mul__(self, *args)
    def getTranslation(self): return _MathLib.TransformationMatrix_getTranslation(self)
    def getLocalCoordTranslation(self): return _MathLib.TransformationMatrix_getLocalCoordTranslation(self)
    def setTranslation(self, *args): return _MathLib.TransformationMatrix_setTranslation(self, *args)
    def clearTranslation(self): return _MathLib.TransformationMatrix_clearTranslation(self)
    def setToTranspose(self): return _MathLib.TransformationMatrix_setToTranspose(self)
    def setToCoordFrameTransformation(self, *args): return _MathLib.TransformationMatrix_setToCoordFrameTransformation(self, *args)
    def setToInverseCoordFrameTransformation(self): return _MathLib.TransformationMatrix_setToInverseCoordFrameTransformation(self)
    def setToInverseCoordFrameTransformationOf(self, *args): return _MathLib.TransformationMatrix_setToInverseCoordFrameTransformationOf(self, *args)
TransformationMatrix_swigregister = _MathLib.TransformationMatrix_swigregister
TransformationMatrix_swigregister(TransformationMatrix)


def testTransformationMatrixClass():
  return _MathLib.testTransformationMatrixClass()
testTransformationMatrixClass = _MathLib.testTransformationMatrixClass
class Vector(Matrix):
    __swig_setmethods__ = {}
    for _s in [Matrix]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector, name, value)
    __swig_getmethods__ = {}
    for _s in [Matrix]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Vector, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _MathLib.new_Vector(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _MathLib.delete_Vector
    __del__ = lambda self : None;
    def shallowCopy(self, *args): return _MathLib.Vector_shallowCopy(self, *args)
    def deepCopy(self, *args): return _MathLib.Vector_deepCopy(self, *args)
    def setToProductOf(self, *args): return _MathLib.Vector_setToProductOf(self, *args)
    def setToRow(self, *args): return _MathLib.Vector_setToRow(self, *args)
    def setToCol(self, *args): return _MathLib.Vector_setToCol(self, *args)
    def printVector(self): return _MathLib.Vector_printVector(self)
    def get(self, *args): return _MathLib.Vector_get(self, *args)
    def set(self, *args): return _MathLib.Vector_set(self, *args)
    def normSquared(self): return _MathLib.Vector_normSquared(self)
Vector_swigregister = _MathLib.Vector_swigregister
Vector_swigregister(Vector)


def testVectorClass():
  return _MathLib.testVectorClass()
testVectorClass = _MathLib.testVectorClass
class ThreeTuple(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreeTuple, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ThreeTuple, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _MathLib.ThreeTuple_x_set
    __swig_getmethods__["x"] = _MathLib.ThreeTuple_x_get
    if _newclass:x = _swig_property(_MathLib.ThreeTuple_x_get, _MathLib.ThreeTuple_x_set)
    __swig_setmethods__["y"] = _MathLib.ThreeTuple_y_set
    __swig_getmethods__["y"] = _MathLib.ThreeTuple_y_get
    if _newclass:y = _swig_property(_MathLib.ThreeTuple_y_get, _MathLib.ThreeTuple_y_set)
    __swig_setmethods__["z"] = _MathLib.ThreeTuple_z_set
    __swig_getmethods__["z"] = _MathLib.ThreeTuple_z_get
    if _newclass:z = _swig_property(_MathLib.ThreeTuple_z_get, _MathLib.ThreeTuple_z_set)
    def __init__(self, *args): 
        this = _MathLib.new_ThreeTuple(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _MathLib.delete_ThreeTuple
    __del__ = lambda self : None;
    def getX(self): return _MathLib.ThreeTuple_getX(self)
    def getY(self): return _MathLib.ThreeTuple_getY(self)
    def getZ(self): return _MathLib.ThreeTuple_getZ(self)
    def setX(self, *args): return _MathLib.ThreeTuple_setX(self, *args)
    def setY(self, *args): return _MathLib.ThreeTuple_setY(self, *args)
    def setZ(self, *args): return _MathLib.ThreeTuple_setZ(self, *args)
    def setValues(self, *args): return _MathLib.ThreeTuple_setValues(self, *args)
    def __eq__(self, *args): return _MathLib.ThreeTuple___eq__(self, *args)
    def __ne__(self, *args): return _MathLib.ThreeTuple___ne__(self, *args)
    def printTuple(self): return _MathLib.ThreeTuple_printTuple(self)
ThreeTuple_swigregister = _MathLib.ThreeTuple_swigregister
ThreeTuple_swigregister(ThreeTuple)

class Vector3d(ThreeTuple):
    __swig_setmethods__ = {}
    for _s in [ThreeTuple]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector3d, name, value)
    __swig_getmethods__ = {}
    for _s in [ThreeTuple]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Vector3d, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _MathLib.new_Vector3d(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _MathLib.delete_Vector3d
    __del__ = lambda self : None;
    def setToSum(self, *args): return _MathLib.Vector3d_setToSum(self, *args)
    def setToCrossProduct(self, *args): return _MathLib.Vector3d_setToCrossProduct(self, *args)
    def __add__(self, *args): return _MathLib.Vector3d___add__(self, *args)
    def setToDifference(self, *args): return _MathLib.Vector3d_setToDifference(self, *args)
    def __sub__(self, *args): return _MathLib.Vector3d___sub__(self, *args)
    def multiplyBy(self, *args): return _MathLib.Vector3d_multiplyBy(self, *args)
    def getOrthogonalVectors(self, *args): return _MathLib.Vector3d_getOrthogonalVectors(self, *args)
    def setToProduct(self, *args): return _MathLib.Vector3d_setToProduct(self, *args)
    def addScaledVector(self, *args): return _MathLib.Vector3d_addScaledVector(self, *args)
    def addVector(self, *args): return _MathLib.Vector3d_addVector(self, *args)
    def setToVectorBetween(self, *args): return _MathLib.Vector3d_setToVectorBetween(self, *args)
    def __mul__(self, *args): return _MathLib.Vector3d___mul__(self, *args)
    def __div__(self, *args): return _MathLib.Vector3d___div__(self, *args)
    def __iadd__(self, *args): return _MathLib.Vector3d___iadd__(self, *args)
    def __isub__(self, *args): return _MathLib.Vector3d___isub__(self, *args)
    def __imul__(self, *args): return _MathLib.Vector3d___imul__(self, *args)
    def __idiv__(self, *args): return _MathLib.Vector3d___idiv__(self, *args)
    def __neg__(self): return _MathLib.Vector3d___neg__(self)
    def dotProductWith(self, *args): return _MathLib.Vector3d_dotProductWith(self, *args)
    def crossProductWith(self, *args): return _MathLib.Vector3d_crossProductWith(self, *args)
    def length(self): return _MathLib.Vector3d_length(self)
    def projectionOn(self, *args): return _MathLib.Vector3d_projectionOn(self, *args)
    def angleWith(self, *args): return _MathLib.Vector3d_angleWith(self, *args)
    def toUnit(self): return _MathLib.Vector3d_toUnit(self)
    def unit(self): return _MathLib.Vector3d_unit(self)
    def isZeroVector(self): return _MathLib.Vector3d_isZeroVector(self)
    def setCrossProductMatrix(self, *args): return _MathLib.Vector3d_setCrossProductMatrix(self, *args)
    def rotate(self, *args): return _MathLib.Vector3d_rotate(self, *args)
Vector3d_swigregister = _MathLib.Vector3d_swigregister
Vector3d_swigregister(Vector3d)

class Point3d(ThreeTuple):
    __swig_setmethods__ = {}
    for _s in [ThreeTuple]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point3d, name, value)
    __swig_getmethods__ = {}
    for _s in [ThreeTuple]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Point3d, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _MathLib.new_Point3d(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _MathLib.delete_Point3d
    __del__ = lambda self : None;
    def setW(self, *args): return _MathLib.Point3d_setW(self, *args)
    def setToOffsetFromPoint(self, *args): return _MathLib.Point3d_setToOffsetFromPoint(self, *args)
    def __add__(self, *args): return _MathLib.Point3d___add__(self, *args)
    def __iadd__(self, *args): return _MathLib.Point3d___iadd__(self, *args)
    def __idiv__(self, *args): return _MathLib.Point3d___idiv__(self, *args)
    def __sub__(self, *args): return _MathLib.Point3d___sub__(self, *args)
    def __neg__(self): return _MathLib.Point3d___neg__(self)
    def __mul__(self, *args): return _MathLib.Point3d___mul__(self, *args)
    def drawObject(self): return _MathLib.Point3d_drawObject(self)
Point3d_swigregister = _MathLib.Point3d_swigregister
Point3d_swigregister(Point3d)

class Quaternion(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Quaternion, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Quaternion, name)
    __repr__ = _swig_repr
    __swig_setmethods__["s"] = _MathLib.Quaternion_s_set
    __swig_getmethods__["s"] = _MathLib.Quaternion_s_get
    if _newclass:s = _swig_property(_MathLib.Quaternion_s_get, _MathLib.Quaternion_s_set)
    __swig_setmethods__["v"] = _MathLib.Quaternion_v_set
    __swig_getmethods__["v"] = _MathLib.Quaternion_v_get
    if _newclass:v = _swig_property(_MathLib.Quaternion_v_get, _MathLib.Quaternion_v_set)
    def __init__(self, *args): 
        this = _MathLib.new_Quaternion(*args)
        try: self.this.append(this)
        except: self.this = this
    def setToProductOf(self, *args): return _MathLib.Quaternion_setToProductOf(self, *args)
    def getRotationAngle(self, *args): return _MathLib.Quaternion_getRotationAngle(self, *args)
    __swig_destroy__ = _MathLib.delete_Quaternion
    __del__ = lambda self : None;
    def getAngle(self): return _MathLib.Quaternion_getAngle(self)
    def getAxis(self): return _MathLib.Quaternion_getAxis(self)
    def getComplexConjugate(self): return _MathLib.Quaternion_getComplexConjugate(self)
    def getInverse(self): return _MathLib.Quaternion_getInverse(self)
    def getLength(self): return _MathLib.Quaternion_getLength(self)
    def dotProductWith(self, *args): return _MathLib.Quaternion_dotProductWith(self, *args)
    def linearlyInterpolateWith(self, *args): return _MathLib.Quaternion_linearlyInterpolateWith(self, *args)
    def sphericallyInterpolateWith(self, *args): return _MathLib.Quaternion_sphericallyInterpolateWith(self, *args)
    __swig_getmethods__["getRotationQuaternion"] = lambda x: _MathLib.Quaternion_getRotationQuaternion
    if _newclass:getRotationQuaternion = staticmethod(_MathLib.Quaternion_getRotationQuaternion)
    def rotate(self, *args): return _MathLib.Quaternion_rotate(self, *args)
    def inverseRotate(self, *args): return _MathLib.Quaternion_inverseRotate(self, *args)
    def getRotationMatrix(self, *args): return _MathLib.Quaternion_getRotationMatrix(self, *args)
    def __imul__(self, *args): return _MathLib.Quaternion___imul__(self, *args)
    def __mul__(self, *args): return _MathLib.Quaternion___mul__(self, *args)
    def __add__(self, *args): return _MathLib.Quaternion___add__(self, *args)
    def __iadd__(self, *args): return _MathLib.Quaternion___iadd__(self, *args)
    def toUnit(self): return _MathLib.Quaternion_toUnit(self)
    def getS(self): return _MathLib.Quaternion_getS(self)
    def getV(self): return _MathLib.Quaternion_getV(self)
    def fastRotate(self, *args): return _MathLib.Quaternion_fastRotate(self, *args)
    def setToRotationQuaternion(self, *args): return _MathLib.Quaternion_setToRotationQuaternion(self, *args)
    def decomposeRotation(self, *args): return _MathLib.Quaternion_decomposeRotation(self, *args)
Quaternion_swigregister = _MathLib.Quaternion_swigregister
Quaternion_swigregister(Quaternion)

def Quaternion_getRotationQuaternion(*args):
  return _MathLib.Quaternion_getRotationQuaternion(*args)
Quaternion_getRotationQuaternion = _MathLib.Quaternion_getRotationQuaternion


def distanceBetweenOrientations(*args):
  return _MathLib.distanceBetweenOrientations(*args)
distanceBetweenOrientations = _MathLib.distanceBetweenOrientations
class Trajectory1d(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Trajectory1d, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Trajectory1d, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _MathLib.new_Trajectory1d(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _MathLib.delete_Trajectory1d
    __del__ = lambda self : None;
    def evaluate_linear(self, *args): return _MathLib.Trajectory1d_evaluate_linear(self, *args)
    def evaluate_catmull_rom(self, *args): return _MathLib.Trajectory1d_evaluate_catmull_rom(self, *args)
    def getKnotValue(self, *args): return _MathLib.Trajectory1d_getKnotValue(self, *args)
    def getKnotPosition(self, *args): return _MathLib.Trajectory1d_getKnotPosition(self, *args)
    def setKnotValue(self, *args): return _MathLib.Trajectory1d_setKnotValue(self, *args)
    def setKnotPosition(self, *args): return _MathLib.Trajectory1d_setKnotPosition(self, *args)
    def getMinPosition(self): return _MathLib.Trajectory1d_getMinPosition(self)
    def getMaxPosition(self): return _MathLib.Trajectory1d_getMaxPosition(self)
    def getKnotCount(self): return _MathLib.Trajectory1d_getKnotCount(self)
    def addKnot(self, *args): return _MathLib.Trajectory1d_addKnot(self, *args)
    def removeKnot(self, *args): return _MathLib.Trajectory1d_removeKnot(self, *args)
    def clear(self): return _MathLib.Trajectory1d_clear(self)
    def simplify_catmull_rom(self, *args): return _MathLib.Trajectory1d_simplify_catmull_rom(self, *args)
    def copy(self, *args): return _MathLib.Trajectory1d_copy(self, *args)
Trajectory1d_swigregister = _MathLib.Trajectory1d_swigregister
Trajectory1d_swigregister(Trajectory1d)

class Trajectory3d(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Trajectory3d, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Trajectory3d, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _MathLib.new_Trajectory3d(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _MathLib.delete_Trajectory3d
    __del__ = lambda self : None;
    def evaluate_linear(self, *args): return _MathLib.Trajectory3d_evaluate_linear(self, *args)
    def evaluate_catmull_rom(self, *args): return _MathLib.Trajectory3d_evaluate_catmull_rom(self, *args)
    def getKnotValue(self, *args): return _MathLib.Trajectory3d_getKnotValue(self, *args)
    def getKnotPosition(self, *args): return _MathLib.Trajectory3d_getKnotPosition(self, *args)
    def setKnotValue(self, *args): return _MathLib.Trajectory3d_setKnotValue(self, *args)
    def setKnotPosition(self, *args): return _MathLib.Trajectory3d_setKnotPosition(self, *args)
    def getMinPosition(self): return _MathLib.Trajectory3d_getMinPosition(self)
    def getMaxPosition(self): return _MathLib.Trajectory3d_getMaxPosition(self)
    def getKnotCount(self): return _MathLib.Trajectory3d_getKnotCount(self)
    def addKnot(self, *args): return _MathLib.Trajectory3d_addKnot(self, *args)
    def removeKnot(self, *args): return _MathLib.Trajectory3d_removeKnot(self, *args)
    def clear(self): return _MathLib.Trajectory3d_clear(self)
    def simplify_catmull_rom(self, *args): return _MathLib.Trajectory3d_simplify_catmull_rom(self, *args)
    def copy(self, *args): return _MathLib.Trajectory3d_copy(self, *args)
Trajectory3d_swigregister = _MathLib.Trajectory3d_swigregister
Trajectory3d_swigregister(Trajectory3d)

class Trajectory3dv(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Trajectory3dv, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Trajectory3dv, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _MathLib.new_Trajectory3dv(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _MathLib.delete_Trajectory3dv
    __del__ = lambda self : None;
    def evaluate_linear(self, *args): return _MathLib.Trajectory3dv_evaluate_linear(self, *args)
    def evaluate_catmull_rom(self, *args): return _MathLib.Trajectory3dv_evaluate_catmull_rom(self, *args)
    def getKnotValue(self, *args): return _MathLib.Trajectory3dv_getKnotValue(self, *args)
    def getKnotPosition(self, *args): return _MathLib.Trajectory3dv_getKnotPosition(self, *args)
    def setKnotValue(self, *args): return _MathLib.Trajectory3dv_setKnotValue(self, *args)
    def setKnotPosition(self, *args): return _MathLib.Trajectory3dv_setKnotPosition(self, *args)
    def getMinPosition(self): return _MathLib.Trajectory3dv_getMinPosition(self)
    def getMaxPosition(self): return _MathLib.Trajectory3dv_getMaxPosition(self)
    def getKnotCount(self): return _MathLib.Trajectory3dv_getKnotCount(self)
    def addKnot(self, *args): return _MathLib.Trajectory3dv_addKnot(self, *args)
    def removeKnot(self, *args): return _MathLib.Trajectory3dv_removeKnot(self, *args)
    def clear(self): return _MathLib.Trajectory3dv_clear(self)
    def simplify_catmull_rom(self, *args): return _MathLib.Trajectory3dv_simplify_catmull_rom(self, *args)
    def copy(self, *args): return _MathLib.Trajectory3dv_copy(self, *args)
Trajectory3dv_swigregister = _MathLib.Trajectory3dv_swigregister
Trajectory3dv_swigregister(Trajectory3dv)



